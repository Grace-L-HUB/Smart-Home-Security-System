# ğŸ”Œ **åŸºäºCH340ä¸²å£é€šä¿¡çš„æ™ºèƒ½å®¶å±…å®‰é˜²ç³»ç»Ÿè¯¦ç»†å¼€å‘æŒ‡å—**

## **1. ä¸²å£é€šä¿¡æ ¸å¿ƒè®¾è®¡**

### **1.1 ç¡¬ä»¶è¿æ¥ç¡®è®¤**
```
STM32F103C8T6          CH340æ¨¡å—
PA9 (USART1_TX)   ->   RXD
PA10 (USART1_RX)  ->   TXD
GND               ->   GND
3.3V/5V           ->   VCC (å»ºè®®3.3V)

é‡è¦æç¤ºï¼š
1. TXæ¥RXï¼ŒRXæ¥TXï¼ˆäº¤å‰è¿æ¥ï¼‰
2. ç¡®ä¿CH340é©±åŠ¨å·²æ­£ç¡®å®‰è£…
3. ç”µè„‘ç«¯ä½¿ç”¨ä¸²å£åŠ©æ‰‹ï¼ˆæ³¢ç‰¹ç‡115200ï¼‰
```

### **1.2 ä¸²å£åˆå§‹åŒ–å…³é”®ä»£ç **
```c
// åœ¨ bsp_uart.c ä¸­
void USART1_Init(uint32_t baudrate)
{
    GPIO_InitTypeDef GPIO_InitStruct;
    USART_InitTypeDef USART_InitStruct;
    NVIC_InitTypeDef NVIC_InitStruct;
    
    // 1. ä½¿èƒ½æ—¶é’Ÿ
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
    
    // 2. é…ç½®TXå¼•è„š(PA9)ä¸ºå¤ç”¨æ¨æŒ½è¾“å‡º
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // 3. é…ç½®RXå¼•è„š(PA10)ä¸ºæµ®ç©ºè¾“å…¥
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // 4. é…ç½®USART1å‚æ•°
    USART_InitStruct.USART_BaudRate = baudrate;  // 115200
    USART_InitStruct.USART_WordLength = USART_WordLength_8b;
    USART_InitStruct.USART_StopBits = USART_StopBits_1;
    USART_InitStruct.USART_Parity = USART_Parity_No;
    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART1, &USART_InitStruct);
    
    // 5. ä½¿èƒ½æ¥æ”¶ä¸­æ–­ï¼ˆå¦‚æœéœ€è¦æ¥æ”¶å‘½ä»¤ï¼‰
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
    
    // 6. é…ç½®NVIC
    NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 3;
    NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStruct);
    
    // 7. ä½¿èƒ½USART1
    USART_Cmd(USART1, ENABLE);
}

// printfé‡å®šå‘ï¼ˆå¿…é¡»å®ç°ï¼‰
#include <stdio.h>
#ifdef __GNUC__
    #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
    #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif

PUTCHAR_PROTOTYPE
{
    USART_SendData(USART1, (uint8_t)ch);
    while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
    return ch;
}
```

### **1.3 è‡ªå®šä¹‰æ•°æ®åè®®è®¾è®¡**
```c
// åœ¨ uart_protocol.h ä¸­å®šä¹‰åè®®æ ¼å¼
typedef enum {
    MSG_TYPE_DATA = 0x01,     // å‘¨æœŸæ€§æ•°æ®
    MSG_TYPE_ALARM = 0x02,    // æŠ¥è­¦ä¿¡æ¯
    MSG_TYPE_EVENT = 0x03,    // ç³»ç»Ÿäº‹ä»¶
    MSG_TYPE_ACK = 0x04,      // åº”ç­”
    MSG_TYPE_CMD = 0x05       // å‘½ä»¤
} MsgType_t;

// æ•°æ®å¸§ç»“æ„
#pragma pack(push, 1)  // 1å­—èŠ‚å¯¹é½
typedef struct {
    uint8_t header[2];      // å¸§å¤´ 0xAA 0x55
    uint8_t type;           // æ¶ˆæ¯ç±»å‹
    uint8_t length;         // æ•°æ®é•¿åº¦
    uint8_t data[32];       // æ•°æ®å†…å®¹ï¼ˆæœ€å¤§32å­—èŠ‚ï¼‰
    uint8_t checksum;       // æ ¡éªŒå’Œ
    uint8_t footer[2];      // å¸§å°¾ 0x0D 0x0A
} UartFrame_t;
#pragma pack(pop)

// æ•°æ®å‘é€å‡½æ•°
void UART_SendDataPacket(MsgType_t type, void *data, uint8_t len)
{
    UartFrame_t frame;
    uint8_t i;
    
    // æ„å»ºå¸§å¤´
    frame.header[0] = 0xAA;
    frame.header[1] = 0x55;
    frame.type = type;
    frame.length = len;
    
    // å¤åˆ¶æ•°æ®
    if(len > 0 && data != NULL) {
        memcpy(frame.data, data, len);
    }
    
    // è®¡ç®—æ ¡éªŒå’Œï¼ˆç®€å•ç´¯åŠ ï¼‰
    frame.checksum = type + len;
    for(i = 0; i < len; i++) {
        frame.checksum += ((uint8_t *)data)[i];
    }
    
    // å¸§å°¾
    frame.footer[0] = 0x0D;
    frame.footer[1] = 0x0A;
    
    // å‘é€å®Œæ•´å¸§
    USART_SendArray(USART1, (uint8_t *)&frame, sizeof(frame));
}
```

## **2. ä¼ æ„Ÿå™¨é©±åŠ¨è¯¦ç»†å®ç°**

### **2.1 DHT11æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨**
```c
// dht11.c - å®Œæ•´é©±åŠ¨å®ç°
#include "stm32f10x.h"
#include "dht11.h"
#include "delay.h"

// å®å®šä¹‰
#define DHT11_PIN     GPIO_Pin_0
#define DHT11_PORT    GPIOA
#define DHT11_RCC     RCC_APB2Periph_GPIOA

// è®¾ç½®å¼•è„šæ¨¡å¼
static void DHT11_Mode_OUT(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(DHT11_RCC, ENABLE);
    
    GPIO_InitStructure.GPIO_Pin = DHT11_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  // æ¨æŒ½è¾“å‡º
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(DHT11_PORT, &GPIO_InitStructure);
}

static void DHT11_Mode_IN(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    GPIO_InitStructure.GPIO_Pin = DHT11_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;     // ä¸Šæ‹‰è¾“å…¥
    GPIO_Init(DHT11_PORT, &GPIO_InitStructure);
}

// è¯»å–ä¸€ä¸ªå­—èŠ‚
static uint8_t DHT11_ReadByte(void)
{
    uint8_t i, temp = 0;
    
    for(i = 0; i < 8; i++) {
        // ç­‰å¾…ä½ç”µå¹³ç»“æŸï¼ˆ50usï¼‰
        while(GPIO_ReadInputDataBit(DHT11_PORT, DHT11_PIN) == RESET);
        
        // å»¶æ—¶40usåˆ¤æ–­é«˜ç”µå¹³æŒç»­æ—¶é—´
        delay_us(40);
        
        // å¦‚æœ40usåè¿˜æ˜¯é«˜ç”µå¹³ï¼Œåˆ™ä¸º1
        if(GPIO_ReadInputDataBit(DHT11_PORT, DHT11_PIN) == SET) {
            temp |= (0x80 >> i);  // é«˜ä½åœ¨å‰
            // ç­‰å¾…ä¿¡å·å˜ä½
            while(GPIO_ReadInputDataBit(DHT11_PORT, DHT11_PIN) == SET);
        }
    }
    return temp;
}

// è¯»å–æ¸©æ¹¿åº¦ï¼ˆä¸»å‡½æ•°ï¼‰
uint8_t DHT11_ReadData(float *temperature, float *humidity)
{
    uint8_t buf[5];
    uint8_t i, checksum;
    
    // 1. ä¸»æœºå‘å‡ºå¼€å§‹ä¿¡å·
    DHT11_Mode_OUT();
    GPIO_ResetBits(DHT11_PORT, DHT11_PIN);  // æ‹‰ä½è‡³å°‘18ms
    delay_ms(20);
    GPIO_SetBits(DHT11_PORT, DHT11_PIN);    // æ‹‰é«˜20-40us
    delay_us(30);
    
    // 2. åˆ‡æ¢ä¸ºè¾“å…¥æ¨¡å¼ç­‰å¾…DHT11å“åº”
    DHT11_Mode_IN();
    
    // 3. ç­‰å¾…DHT11æ‹‰ä½å“åº”ä¿¡å·
    if(GPIO_ReadInputDataBit(DHT11_PORT, DHT11_PIN) == SET) return 1;  // æ— å“åº”
    delay_us(80);  // ç­‰å¾…ä½ç”µå¹³ç»“æŸ
    
    if(GPIO_ReadInputDataBit(DHT11_PORT, DHT11_PIN) == RESET) return 2;  // æ— å“åº”
    
    // ç­‰å¾…é«˜ç”µå¹³ç»“æŸ
    while(GPIO_ReadInputDataBit(DHT11_PORT, DHT11_PIN) == SET);
    
    // 4. è¯»å–40ä½æ•°æ®
    for(i = 0; i < 5; i++) {
        buf[i] = DHT11_ReadByte();
    }
    
    // 5. æ ¡éªŒæ•°æ®
    checksum = buf[0] + buf[1] + buf[2] + buf[3];
    if(checksum != buf[4]) return 3;  // æ ¡éªŒå¤±è´¥
    
    // 6. è½¬æ¢ä¸ºå®é™…å€¼
    if(humidity != NULL) {
        *humidity = buf[0] + buf[1] * 0.1;  // æ¹¿åº¦
    }
    if(temperature != NULL) {
        *temperature = buf[2] + buf[3] * 0.1;  // æ¸©åº¦
    }
    
    return 0;  // æˆåŠŸ
}

// DHT11åˆå§‹åŒ–
void DHT11_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(DHT11_RCC, ENABLE);
    
    // åˆå§‹åŒ–ä¸ºè¾“å‡ºï¼Œå¹¶æ‹‰é«˜
    GPIO_InitStructure.GPIO_Pin = DHT11_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(DHT11_PORT, &GPIO_InitStructure);
    
    GPIO_SetBits(DHT11_PORT, DHT11_PIN);  // åˆå§‹é«˜ç”µå¹³
}
```

### **2.2 çº¢å¤–ä¼ æ„Ÿå™¨æ£€æµ‹ï¼ˆå¸¦é˜²æŠ–åŠ¨ï¼‰**
```c
// infrared.c - çº¢å¤–ä¼ æ„Ÿå™¨å¤„ç†
#include "stm32f10x.h"
#include "infrared.h"
#include "systick.h"

#define IR_SENSOR_PIN     GPIO_Pin_1
#define IR_SENSOR_PORT    GPIOA

// çº¢å¤–ä¼ æ„Ÿå™¨çŠ¶æ€æœº
typedef struct {
    uint8_t current_state;      // å½“å‰çŠ¶æ€
    uint8_t last_state;         // ä¸Šä¸€æ¬¡çŠ¶æ€
    uint32_t trigger_time;      // è§¦å‘æ—¶é—´
    uint8_t trigger_count;      // è§¦å‘æ¬¡æ•°ï¼ˆç”¨äºé˜²è¯¯æŠ¥ï¼‰
    uint8_t confirmed_alarm;    // å·²ç¡®è®¤çš„æŠ¥è­¦
} Infrared_State_t;

static Infrared_State_t ir_state = {0};

// åˆå§‹åŒ–
void Infrared_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    GPIO_InitStructure.GPIO_Pin = IR_SENSOR_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  // ä¸Šæ‹‰è¾“å…¥
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(IR_SENSOR_PORT, &GPIO_InitStructure);
    
    // åˆå§‹çŠ¶æ€
    ir_state.current_state = GPIO_ReadInputDataBit(IR_SENSOR_PORT, IR_SENSOR_PIN);
    ir_state.last_state = ir_state.current_state;
    ir_state.trigger_count = 0;
    ir_state.confirmed_alarm = 0;
}

// æ£€æŸ¥çº¢å¤–çŠ¶æ€ï¼ˆåœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨ï¼Œå»ºè®®100msä¸€æ¬¡ï¼‰
uint8_t Infrared_Check(void)
{
    static uint32_t last_check_time = 0;
    uint32_t current_time = GetSysTick();
    uint8_t sensor_value;
    
    // å®šæ—¶æ£€æŸ¥ï¼ˆ100msï¼‰
    if(current_time - last_check_time < 100) {
        return ir_state.confirmed_alarm;
    }
    last_check_time = current_time;
    
    // è¯»å–ä¼ æ„Ÿå™¨å€¼ï¼ˆ0:æ£€æµ‹åˆ°ç‰©ä½“ï¼Œ1:æ— ç‰©ä½“ï¼‰
    sensor_value = GPIO_ReadInputDataBit(IR_SENSOR_PORT, IR_SENSOR_PIN);
    
    // çŠ¶æ€æ›´æ–°
    ir_state.last_state = ir_state.current_state;
    ir_state.current_state = sensor_value;
    
    // æ£€æµ‹åˆ°ä¸‹é™æ²¿ï¼ˆä»1åˆ°0ï¼Œè¡¨ç¤ºç‰©ä½“è¿›å…¥ï¼‰
    if(ir_state.last_state == 1 && ir_state.current_state == 0) {
        ir_state.trigger_time = current_time;
        ir_state.trigger_count++;
        
        // é˜²è¯¯æŠ¥ç­–ç•¥ï¼šè¿ç»­2æ¬¡æ£€æµ‹åˆ°æ‰ç¡®è®¤ä¸ºæœ‰æ•ˆè§¦å‘
        if(ir_state.trigger_count >= 2) {
            ir_state.confirmed_alarm = 1;
            printf("[IR] Intrusion detected! Count: %d\n", ir_state.trigger_count);
        }
    }
    
    // æ£€æµ‹åˆ°ä¸Šå‡æ²¿ï¼ˆä»0åˆ°1ï¼Œè¡¨ç¤ºç‰©ä½“ç¦»å¼€ï¼‰
    if(ir_state.last_state == 0 && ir_state.current_state == 1) {
        // ç‰©ä½“ç¦»å¼€ï¼Œé‡ç½®è®¡æ•°ï¼ˆå¦‚æœæŠ¥è­¦æœªç¡®è®¤ï¼‰
        if(!ir_state.confirmed_alarm) {
            ir_state.trigger_count = 0;
        }
    }
    
    // æŠ¥è­¦ç¡®è®¤åçš„å¤„ç†
    if(ir_state.confirmed_alarm) {
        // æŠ¥è­¦æŒç»­10ç§’åè‡ªåŠ¨å¤ä½
        if(current_time - ir_state.trigger_time > 10000) {  // 10ç§’
            ir_state.confirmed_alarm = 0;
            ir_state.trigger_count = 0;
            printf("[IR] Alarm auto-reset after 10s\n");
        }
    }
    
    return ir_state.confirmed_alarm;
}

// æ‰‹åŠ¨æ¸…é™¤æŠ¥è­¦
void Infrared_ClearAlarm(void)
{
    ir_state.confirmed_alarm = 0;
    ir_state.trigger_count = 0;
}
```

## **3. EC11ç¼–ç å™¨è¯¦ç»†é©±åŠ¨**

### **3.1 ç¼–ç å™¨æ¨¡å¼é…ç½®ï¼ˆä½¿ç”¨TIM3ï¼‰**
```c
// encoder.c - EC11ç¼–ç å™¨é©±åŠ¨
#include "stm32f10x.h"
#include "encoder.h"
#include "systick.h"

// ç¼–ç å™¨çŠ¶æ€
typedef struct {
    int32_t counter;          // ç¼–ç å™¨è®¡æ•°å€¼
    uint8_t button_state;     // æŒ‰é”®çŠ¶æ€
    uint8_t button_pressed;   // æŒ‰é”®æŒ‰ä¸‹æ ‡å¿—
    uint8_t button_long_press; // é•¿æŒ‰æ ‡å¿—
    uint32_t button_time;     // æŒ‰é”®æ—¶é—´æˆ³
} Encoder_State_t;

static Encoder_State_t encoder = {0};

// åˆå§‹åŒ–TIM3ä¸ºç¼–ç å™¨æ¨¡å¼
void Encoder_TIM3_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    TIM_ICInitTypeDef TIM_ICInitStructure;
    
    // 1. ä½¿èƒ½æ—¶é’Ÿ
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    
    // 2. é…ç½®PB0, PB1ä¸ºæµ®ç©ºè¾“å…¥
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    // 3. å®šæ—¶å™¨åŸºç¡€é…ç½®
    TIM_TimeBaseStructure.TIM_Period = 65535;  // 16ä½æœ€å¤§å€¼
    TIM_TimeBaseStructure.TIM_Prescaler = 0;
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    
    // 4. ç¼–ç å™¨æ¥å£é…ç½®
    TIM_EncoderInterfaceConfig(TIM3, 
        TIM_EncoderMode_TI12,      // åœ¨TI1å’ŒTI2ä¸Šè®¡æ•°
        TIM_ICPolarity_Rising,     // ææ€§
        TIM_ICPolarity_Rising);
    
    // 5. è¾“å…¥æ•è·é…ç½®ï¼ˆæ»¤æ³¢é˜²æŠ–åŠ¨ï¼‰
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0x0F;  // æ»¤æ³¢ç³»æ•°
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
    
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
    TIM_ICInitStructure.TIM_ICFilter = 0x0F;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
    
    // 6. ä½¿èƒ½TIM3
    TIM_Cmd(TIM3, ENABLE);
    
    // åˆå§‹åŒ–è®¡æ•°å™¨
    TIM_SetCounter(TIM3, 32768);  // è®¾ç½®ä¸­é—´å€¼ï¼Œé¿å…æº¢å‡º
    encoder.counter = 32768;
}

// åˆå§‹åŒ–æŒ‰é”®ï¼ˆPB2ï¼Œå¤–éƒ¨ä¸­æ–­ï¼‰
void Encoder_Button_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    EXTI_InitTypeDef EXTI_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    
    // 1. é…ç½®PB2ä¸ºä¸Šæ‹‰è¾“å…¥
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    // 2. é…ç½®EXTI
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource2);
    
    EXTI_InitStructure.EXTI_Line = EXTI_Line2;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  // ä¸‹é™æ²¿è§¦å‘
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
    
    // 3. é…ç½®NVIC
    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

// è·å–ç¼–ç å™¨å˜åŒ–å€¼
int16_t Encoder_GetDelta(void)
{
    int16_t delta;
    uint16_t current_count = TIM_GetCounter(TIM3);
    
    // è®¡ç®—å˜åŒ–é‡ï¼ˆå¤„ç†è®¡æ•°å™¨æº¢å‡ºï¼‰
    if(current_count >= 32768 && encoder.counter < 32768) {
        delta = (int16_t)(current_count - 65536 - encoder.counter);
    } else if(current_count < 32768 && encoder.counter >= 32768) {
        delta = (int16_t)(current_count + 65536 - encoder.counter);
    } else {
        delta = (int16_t)(current_count - encoder.counter);
    }
    
    encoder.counter += delta;
    
    // æ›´æ–°ç¡¬ä»¶è®¡æ•°å™¨ï¼Œä¿æŒåœ¨ä¸­é—´åŒºåŸŸ
    TIM_SetCounter(TIM3, 32768);
    encoder.counter = 32768;
    
    return delta;
}

// æŒ‰é”®ä¸­æ–­æœåŠ¡å‡½æ•°
void EXTI2_IRQHandler(void)
{
    static uint32_t last_press_time = 0;
    uint32_t current_time = GetSysTick();
    
    if(EXTI_GetITStatus(EXTI_Line2) != RESET) {
        // é˜²æŠ–åŠ¨ï¼šè‡³å°‘é—´éš”50ms
        if(current_time - last_press_time > 50) {
            encoder.button_pressed = 1;
            encoder.button_time = current_time;
            last_press_time = current_time;
        }
        
        EXTI_ClearITPendingBit(EXTI_Line2);
    }
}

// æŒ‰é”®å¤„ç†ï¼ˆåœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨ï¼‰
uint8_t Encoder_ProcessButton(void)
{
    uint32_t current_time = GetSysTick();
    uint8_t result = 0;
    
    if(encoder.button_pressed) {
        // æ£€æµ‹é•¿æŒ‰ï¼ˆè¶…è¿‡1ç§’ï¼‰
        if(current_time - encoder.button_time > 1000) {
            encoder.button_long_press = 1;
            result = BUTTON_LONG_PRESS;
            printf("[ENC] Button long press\n");
        }
        // çŸ­æŒ‰ï¼ˆå·²é‡Šæ”¾ï¼‰
        else if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_2) == 1) {
            encoder.button_long_press = 0;
            result = BUTTON_SHORT_PRESS;
            printf("[ENC] Button short press\n");
            encoder.button_pressed = 0;  // æ¸…é™¤æ ‡å¿—
        }
    }
    
    return result;
}

// è·å–æ—‹è½¬æ–¹å‘ï¼ˆç®€åŒ–æ¥å£ï¼‰
int8_t Encoder_GetDirection(void)
{
    int16_t delta = Encoder_GetDelta();
    
    if(delta > 0) {
        printf("[ENC] Rotated CW, delta: %d\n", delta);
        return 1;  // é¡ºæ—¶é’ˆ
    } else if(delta < 0) {
        printf("[ENC] Rotated CCW, delta: %d\n", delta);
        return -1; // é€†æ—¶é’ˆ
    }
    
    return 0;  // æ— å˜åŒ–
}
```

## **4. OLEDèœå•ç³»ç»Ÿå®ç°**

### **4.1 èœå•æ•°æ®ç»“æ„**
```c
// menu.h - èœå•ç³»ç»Ÿå®šä¹‰
#ifndef __MENU_H
#define __MENU_H

#include <stdint.h>

// èœå•é¡¹ç±»å‹
typedef enum {
    MENU_ITEM_NORMAL,      // æ™®é€šèœå•é¡¹
    MENU_ITEM_TOGGLE,      // å¼€å…³é¡¹
    MENU_ITEM_VALUE,       // æ•°å€¼é¡¹
    MENU_ITEM_SUBMENU,     // å­èœå•
    MENU_ITEM_ACTION       // æ‰§è¡ŒåŠ¨ä½œ
} MenuItemType_t;

// èœå•é¡¹ç»“æ„
typedef struct MenuItem {
    char *name;                     // æ˜¾ç¤ºåç§°
    MenuItemType_t type;            // ç±»å‹
    uint8_t *value_ptr;             // å€¼æŒ‡é’ˆï¼ˆç”¨äºå¼€å…³/æ•°å€¼ï¼‰
    uint8_t min_value;              // æœ€å°å€¼
    uint8_t max_value;              // æœ€å¤§å€¼
    uint8_t step;                   // æ­¥è¿›å€¼
    void (*action)(void);           // åŠ¨ä½œå‡½æ•°
    struct MenuItem *parent;        // çˆ¶èœå•
    struct MenuItem *child;         // å­èœå•
    struct MenuItem *next;          // ä¸‹ä¸€ä¸ªå…„å¼Ÿ
} MenuItem_t;

// èœå•ç³»ç»ŸçŠ¶æ€
typedef struct {
    MenuItem_t *current_menu;      // å½“å‰èœå•
    MenuItem_t *current_item;      // å½“å‰é€‰ä¸­é¡¹
    uint8_t item_index;            // å½“å‰é¡¹ç´¢å¼•
    uint8_t edit_mode;             // ç¼–è¾‘æ¨¡å¼
    uint8_t need_redraw;           // éœ€è¦é‡ç»˜æ ‡å¿—
} MenuSystem_t;

// èœå•æ“ä½œç»“æœ
typedef enum {
    MENU_OK,
    MENU_EXIT,
    MENU_ENTER_SUBMENU,
    MENU_ACTION_COMPLETE
} MenuResult_t;

// å…¬å¼€å‡½æ•°
void Menu_Init(void);
MenuResult_t Menu_ProcessEncoder(int8_t direction, uint8_t button_action);
void Menu_Draw(void);

#endif
```

### **4.2 èœå•ç³»ç»Ÿå®ç°**
```c
// menu.c - èœå•ç³»ç»Ÿæ ¸å¿ƒ
#include "menu.h"
#include "oled.h"
#include "encoder.h"
#include "security.h"
#include <string.h>

// å®šä¹‰èœå•é¡¹ï¼ˆæ ¹æ®ä½ çš„éœ€æ±‚ä¿®æ”¹ï¼‰
static MenuItem_t menu_items[] = {
    // ä¸»èœå•é¡¹
    {"ç³»ç»ŸçŠ¶æ€", MENU_ITEM_NORMAL, NULL, 0, 0, 0, NULL, NULL, NULL, &menu_items[1]},
    {"æ¨¡å¼è®¾ç½®", MENU_ITEM_SUBMENU, NULL, 0, 0, 0, NULL, NULL, &menu_items[4], &menu_items[2]},
    {"æŠ¥è­¦è®°å½•", MENU_ITEM_ACTION, NULL, 0, 0, 0, Menu_ShowAlarmLog, NULL, NULL, &menu_items[3]},
    {"ç³»ç»Ÿä¿¡æ¯", MENU_ITEM_ACTION, NULL, 0, 0, 0, Menu_ShowSystemInfo, NULL, NULL, NULL},
    
    // æ¨¡å¼å­èœå•
    {"å¸ƒé˜²æ¨¡å¼", MENU_ITEM_ACTION, NULL, 0, 0, 0, Security_SetArmedMode, &menu_items[1], NULL, &menu_items[5]},
    {"å±…å®¶æ¨¡å¼", MENU_ITEM_ACTION, NULL, 0, 0, 0, Security_SetHomeMode, &menu_items[1], NULL, &menu_items[6]},
    {"è°ƒè¯•æ¨¡å¼", MENU_ITEM_ACTION, NULL, 0, 0, 0, Security_SetDebugMode, &menu_items[1], NULL, NULL}
};

static MenuSystem_t menu_sys;

// åˆå§‹åŒ–èœå•ç³»ç»Ÿ
void Menu_Init(void)
{
    // è®¾ç½®èœå•å…³ç³»
    menu_sys.current_menu = &menu_items[0];  // ä¸»èœå•
    menu_sys.current_item = &menu_items[0];  // ç¬¬ä¸€ä¸ªé¡¹
    menu_sys.item_index = 0;
    menu_sys.edit_mode = 0;
    menu_sys.need_redraw = 1;
    
    // è®¾ç½®çˆ¶èœå•æŒ‡é’ˆ
    for(uint8_t i = 0; i < sizeof(menu_items)/sizeof(MenuItem_t); i++) {
        if(menu_items[i].next != NULL) {
            menu_items[i].next->parent = menu_items[i].parent;
        }
    }
}

// å¤„ç†ç¼–ç å™¨è¾“å…¥
MenuResult_t Menu_ProcessEncoder(int8_t direction, uint8_t button_action)
{
    MenuItem_t *item = menu_sys.current_item;
    
    // ç¼–è¾‘æ¨¡å¼
    if(menu_sys.edit_mode && item != NULL) {
        if(direction > 0) {
            // å¢åŠ æ•°å€¼
            if(item->value_ptr != NULL && *item->value_ptr < item->max_value) {
                *item->value_ptr += item->step;
                menu_sys.need_redraw = 1;
            }
        } else if(direction < 0) {
            // å‡å°‘æ•°å€¼
            if(item->value_ptr != NULL && *item->value_ptr > item->min_value) {
                *item->value_ptr -= item->step;
                menu_sys.need_redraw = 1;
            }
        }
        
        // æŒ‰é”®é€€å‡ºç¼–è¾‘æ¨¡å¼
        if(button_action == BUTTON_SHORT_PRESS) {
            menu_sys.edit_mode = 0;
            menu_sys.need_redraw = 1;
            return MENU_OK;
        }
    }
    // æµè§ˆæ¨¡å¼
    else {
        // æ—‹è½¬ï¼šä¸Šä¸‹é€‰æ‹©
        if(direction > 0) {
            // å‘ä¸‹é€‰æ‹©
            if(item != NULL && item->next != NULL) {
                menu_sys.current_item = item->next;
                menu_sys.item_index++;
                menu_sys.need_redraw = 1;
            }
        } else if(direction < 0) {
            // å‘ä¸Šé€‰æ‹©
            if(item != NULL && item != menu_sys.current_menu) {
                // æ‰¾åˆ°å‰ä¸€ä¸ªé¡¹
                MenuItem_t *prev = menu_sys.current_menu;
                while(prev != NULL && prev->next != item) {
                    prev = prev->next;
                }
                if(prev != NULL) {
                    menu_sys.current_item = prev;
                    menu_sys.item_index--;
                    menu_sys.need_redraw = 1;
                }
            }
        }
        
        // æŒ‰é”®ï¼šç¡®è®¤/è¿›å…¥/æ‰§è¡Œ
        if(button_action == BUTTON_SHORT_PRESS && item != NULL) {
            switch(item->type) {
                case MENU_ITEM_SUBMENU:
                    // è¿›å…¥å­èœå•
                    if(item->child != NULL) {
                        menu_sys.current_menu = item;
                        menu_sys.current_item = item->child;
                        menu_sys.item_index = 0;
                        menu_sys.need_redraw = 1;
                        return MENU_ENTER_SUBMENU;
                    }
                    break;
                    
                case MENU_ITEM_ACTION:
                    // æ‰§è¡ŒåŠ¨ä½œ
                    if(item->action != NULL) {
                        item->action();
                        menu_sys.need_redraw = 1;
                        return MENU_ACTION_COMPLETE;
                    }
                    break;
                    
                case MENU_ITEM_TOGGLE:
                case MENU_ITEM_VALUE:
                    // è¿›å…¥ç¼–è¾‘æ¨¡å¼
                    if(item->value_ptr != NULL) {
                        menu_sys.edit_mode = 1;
                        menu_sys.need_redraw = 1;
                    }
                    break;
                    
                default:
                    break;
            }
        }
        
        // é•¿æŒ‰ï¼šè¿”å›ä¸Šçº§
        if(button_action == BUTTON_LONG_PRESS) {
            if(menu_sys.current_menu != NULL && menu_sys.current_menu->parent != NULL) {
                menu_sys.current_item = menu_sys.current_menu;
                menu_sys.current_menu = menu_sys.current_menu->parent;
                menu_sys.item_index = 0;
                menu_sys.need_redraw = 1;
                return MENU_EXIT;
            }
        }
    }
    
    return MENU_OK;
}

// ç»˜åˆ¶èœå•
void Menu_Draw(void)
{
    if(!menu_sys.need_redraw) return;
    
    OLED_Clear();
    
    // ç»˜åˆ¶èœå•æ ‡é¢˜
    OLED_ShowString(0, 0, menu_sys.current_menu->name, 16, 1);
    OLED_DrawLine(0, 16, 127, 16, 1);
    
    // ç»˜åˆ¶èœå•é¡¹ï¼ˆæœ€å¤šæ˜¾ç¤º3é¡¹ï¼‰
    MenuItem_t *item = menu_sys.current_item;
    uint8_t line = 2;  // ä»ç¬¬2è¡Œå¼€å§‹
    
    for(uint8_t i = 0; i < 3 && item != NULL; i++) {
        char buffer[20];
        
        // å½“å‰é€‰ä¸­é¡¹å‰åŠ ">"
        if(item == menu_sys.current_item) {
            if(menu_sys.edit_mode) {
                snprintf(buffer, sizeof(buffer), ">%s: %d <", item->name, 
                         item->value_ptr ? *item->value_ptr : 0);
            } else {
                snprintf(buffer, sizeof(buffer), ">%s", item->name);
            }
            OLED_ShowString(0, line*8, buffer, 8, 1);
        } else {
            snprintf(buffer, sizeof(buffer), " %s", item->name);
            OLED_ShowString(0, line*8, buffer, 8, 0);
        }
        
        line++;
        item = item->next;
    }
    
    // åº•éƒ¨æç¤º
    if(menu_sys.edit_mode) {
        OLED_ShowString(0, 56, "æ—‹è½¬è°ƒæ•´ çŸ­æŒ‰ç¡®è®¤", 8, 1);
    } else {
        OLED_ShowString(0, 56, "æ—‹è½¬é€‰æ‹© çŸ­æŒ‰ç¡®è®¤ é•¿æŒ‰è¿”å›", 8, 1);
    }
    
    menu_sys.need_redraw = 0;
    OLED_Refresh();
}
```

## **5. ä¸»ç¨‹åºæ¶æ„ä¸çŠ¶æ€æœº**

### **5.1 ä¸»ç¨‹åºç»“æ„**
```c
// main.c - ç³»ç»Ÿä¸»ç¨‹åº
#include "stm32f10x.h"
#include "bsp_sys.h"
#include "bsp_uart.h"
#include "bsp_oled.h"
#include "bsp_encoder.h"
#include "dht11.h"
#include "infrared.h"
#include "menu.h"
#include "security.h"
#include "systick.h"
#include <stdio.h>

// å…¨å±€å˜é‡
SystemStatus_t sys_status;

// ç³»ç»Ÿåˆå§‹åŒ–
void System_Init(void)
{
    // 1. ç³»ç»Ÿæ—¶é’Ÿåˆå§‹åŒ–ï¼ˆ72MHzï¼‰
    SystemClock_Config();
    
    // 2. Systickå®šæ—¶å™¨åˆå§‹åŒ–ï¼ˆ1msï¼‰
    SysTick_Init();
    
    // 3. ä¸²å£åˆå§‹åŒ–ï¼ˆ115200ï¼‰
    USART1_Init(115200);
    printf("\n\n===== Smart Home Security System =====\n");
    printf("MCU: STM32F103C8T6 @ 72MHz\n");
    printf("Version: 1.0\n");
    printf("Build Date: %s %s\n", __DATE__, __TIME__);
    
    // 4. OLEDåˆå§‹åŒ–
    OLED_Init();
    OLED_Clear();
    OLED_ShowString(0, 0, "Initializing...", 16, 1);
    OLED_Refresh();
    
    // 5. å¤–è®¾åˆå§‹åŒ–
    LED_Init();          // LEDæŒ‡ç¤ºç¯
    Buzzer_Init();       // èœ‚é¸£å™¨
    DHT11_Init();        // æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨
    Infrared_Init();     // çº¢å¤–ä¼ æ„Ÿå™¨
    Encoder_TIM3_Init(); // ç¼–ç å™¨
    Encoder_Button_Init();
    
    // 6. åº”ç”¨å±‚åˆå§‹åŒ–
    Menu_Init();         // èœå•ç³»ç»Ÿ
    Security_Init();     // å®‰é˜²ç³»ç»Ÿ
    
    // 7. æ˜¾ç¤ºæ¬¢è¿ç•Œé¢
    OLED_Clear();
    OLED_ShowChinese(24, 0, 0, 16);  // æ™º
    OLED_ShowChinese(40, 0, 1, 16);  // èƒ½
    OLED_ShowChinese(56, 0, 2, 16);  // å®¶
    OLED_ShowChinese(72, 0, 3, 16);  // å±…
    OLED_ShowString(24, 2, "Security System", 16, 1);
    OLED_Refresh();
    
    delay_ms(2000);
    
    printf("[SYS] System initialized successfully!\n");
}

// ä¸»å¾ªç¯
int main(void)
{
    static uint32_t last_sensor_time = 0;
    static uint32_t last_uart_time = 0;
    static uint32_t last_display_time = 0;
    
    // ç³»ç»Ÿåˆå§‹åŒ–
    System_Init();
    
    // ä¸»å¾ªç¯
    while(1) {
        uint32_t current_time = GetSysTick();
        
        // 1. å¤„ç†ç¼–ç å™¨è¾“å…¥ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
        int8_t enc_dir = Encoder_GetDirection();
        uint8_t btn_action = Encoder_ProcessButton();
        
        if(enc_dir != 0 || btn_action != 0) {
            Menu_ProcessEncoder(enc_dir, btn_action);
        }
        
        // 2. ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ï¼ˆæ¯2ç§’ï¼‰
        if(current_time - last_sensor_time > 2000) {
            float temp, humi;
            uint8_t dht_result = DHT11_ReadData(&temp, &humi);
            
            if(dht_result == 0) {
                sys_status.temperature = temp;
                sys_status.humidity = humi;
                printf("[SENS] Temp: %.1fC, Humi: %.1f%%\n", temp, humi);
            } else {
                printf("[SENS] DHT11 read error: %d\n", dht_result);
            }
            
            // æ£€æŸ¥çº¢å¤–ä¼ æ„Ÿå™¨
            uint8_t ir_alarm = Infrared_Check();
            if(ir_alarm) {
                Security_HandleAlarm(ALARM_INTRUSION);
            }
            
            last_sensor_time = current_time;
        }
        
        // 3. ä¸²å£æ•°æ®å‘é€ï¼ˆæ¯5ç§’ï¼‰
        if(current_time - last_uart_time > 5000) {
            // å‘é€ç³»ç»ŸçŠ¶æ€
            printf("[UART] Mode:%d, Alarm:%d, Temp:%.1f, Humi:%.1f\n",
                   sys_status.mode, sys_status.alarm_state,
                   sys_status.temperature, sys_status.humidity);
            
            last_uart_time = current_time;
        }
        
        // 4. æ›´æ–°æ˜¾ç¤ºï¼ˆæ¯100msï¼‰
        if(current_time - last_display_time > 100) {
            Menu_Draw();  // èœå•ä¼šè‡ªåŠ¨åˆ¤æ–­æ˜¯å¦éœ€è¦é‡ç»˜
            last_display_time = current_time;
        }
        
        // 5. å®‰é˜²ç³»ç»Ÿå¤„ç†
        Security_Process();
        
        // 6. ç©ºé—²æ—¶è¿›å…¥ä½åŠŸè€—ï¼ˆå¯é€‰ï¼‰
        // __WFI();
    }
}
```

### **5.2 å®‰é˜²çŠ¶æ€æœº**
```c
// security.c - å®‰é˜²æ ¸å¿ƒé€»è¾‘
#include "security.h"
#include "bsp_beep.h"
#include "bsp_led.h"
#include "menu.h"
#include <stdio.h>

SystemStatus_t sys_status = {
    .mode = MODE_HOME,
    .alarm_state = ALARM_IDLE,
    .temperature = 0,
    .humidity = 0,
    .last_alarm_time = 0
};

// å®‰é˜²ç³»ç»Ÿåˆå§‹åŒ–
void Security_Init(void)
{
    sys_status.mode = MODE_HOME;
    sys_status.alarm_state = ALARM_IDLE;
    printf("[SEC] Security system initialized. Mode: HOME\n");
}

// å¤„ç†æŠ¥è­¦
void Security_HandleAlarm(AlarmType_t alarm_type)
{
    // æ ¹æ®å½“å‰æ¨¡å¼å†³å®šå“åº”
    switch(sys_status.mode) {
        case MODE_ARMED:  // å¸ƒé˜²æ¨¡å¼ï¼šç«‹å³æŠ¥è­¦
            if(sys_status.alarm_state == ALARM_IDLE) {
                sys_status.alarm_state = ALARM_ACTIVE;
                sys_status.last_alarm_time = GetSysTick();
                
                // å£°å…‰æŠ¥è­¦
                Buzzer_AlarmPattern(ALARM_PATTERN_FAST);
                LED_FlashPattern(LED_PATTERN_FAST);
                
                // ä¸²å£é€šçŸ¥
                printf("[ALARM] Intrusion detected in ARMED mode!\n");
                
                // OLEDæ˜¾ç¤ºè­¦æŠ¥ï¼ˆå¯é€šè¿‡èœå•ç³»ç»Ÿæ˜¾ç¤ºï¼‰
            }
            break;
            
        case MODE_HOME:   // å±…å®¶æ¨¡å¼ï¼šä»…è®°å½•
            printf("[EVENT] Motion detected in HOME mode (no alarm)\n");
            break;
            
        case MODE_DEBUG:  // è°ƒè¯•æ¨¡å¼ï¼šä»…æ‰“å°
            printf("[DEBUG] Sensor triggered. No action taken.\n");
            break;
    }
}

// å®‰é˜²å¤„ç†ä¸»å‡½æ•°
void Security_Process(void)
{
    static uint32_t last_process_time = 0;
    uint32_t current_time = GetSysTick();
    
    // æ¯100mså¤„ç†ä¸€æ¬¡
    if(current_time - last_process_time < 100) return;
    last_process_time = current_time;
    
    // å¤„ç†æŠ¥è­¦çŠ¶æ€
    switch(sys_status.alarm_state) {
        case ALARM_ACTIVE:
            // æŠ¥è­¦æŒç»­10ç§’åè‡ªåŠ¨åœæ­¢
            if(current_time - sys_status.last_alarm_time > 10000) {
                sys_status.alarm_state = ALARM_IDLE;
                Buzzer_Stop();
                LED_SetState(LED_OFF);
                printf("[SEC] Alarm auto-cleared after 10s\n");
            }
            break;
            
        case ALARM_IDLE:
            // ç©ºé—²çŠ¶æ€ï¼Œå¯æ‰§è¡Œå…¶ä»–æ£€æŸ¥
            break;
    }
}

// æ¨¡å¼è®¾ç½®å‡½æ•°
void Security_SetArmedMode(void)
{
    sys_status.mode = MODE_ARMED;
    printf("[SEC] Mode changed to ARMED\n");
}

void Security_SetHomeMode(void)
{
    sys_status.mode = MODE_HOME;
    printf("[SEC] Mode changed to HOME\n");
}

void Security_SetDebugMode(void)
{
    sys_status.mode = MODE_DEBUG;
    printf("[SEC] Mode changed to DEBUG\n");
}
```

## **6. è°ƒè¯•ä¸æµ‹è¯•æŒ‡å—**

### **6.1 ä¸²å£è°ƒè¯•å‘½ä»¤**
ç³»ç»Ÿæ”¯æŒé€šè¿‡ä¸²å£å‘é€ç®€å•å‘½ä»¤ï¼š
```
å‘½ä»¤æ ¼å¼ï¼šcmd [å‚æ•°]\n

å¯ç”¨å‘½ä»¤ï¼š
help                 - æ˜¾ç¤ºå¸®åŠ©
mode [0-2]           - è®¾ç½®æ¨¡å¼(0:å¸ƒé˜²,1:å±…å®¶,2:è°ƒè¯•)
status               - æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€
clear                - æ¸…é™¤æŠ¥è­¦
reset                - è½¯ä»¶å¤ä½
```

### **6.2 æµ‹è¯•æµç¨‹**
1. **ç¼–è¯‘ä¸‹è½½**ï¼šç¡®ä¿å·¥ç¨‹ç¼–è¯‘0é”™è¯¯0è­¦å‘Š
2. **ä¸²å£è¿æ¥**ï¼šæ‰“å¼€ä¸²å£åŠ©æ‰‹ï¼Œè®¾ç½®115200æ³¢ç‰¹ç‡
3. **ä¸Šç”µæµ‹è¯•**ï¼šåº”è¯¥çœ‹åˆ°å¯åŠ¨ä¿¡æ¯
4. **ä¼ æ„Ÿå™¨æµ‹è¯•**ï¼š
   - è§‚å¯ŸDHT11æ•°æ®æ˜¯å¦æ­£å¸¸
   - ç”¨æ‰‹é®æŒ¡çº¢å¤–ä¼ æ„Ÿå™¨ï¼Œæ£€æŸ¥æŠ¥è­¦
5. **ç¼–ç å™¨æµ‹è¯•**ï¼š
   - æ—‹è½¬ç¼–ç å™¨ï¼ŒOLEDèœå•åº”å“åº”
   - æŒ‰ä¸‹ç¼–ç å™¨ï¼Œåº”èƒ½é€‰æ‹©èœå•é¡¹
6. **æ¨¡å¼åˆ‡æ¢**ï¼šé€šè¿‡èœå•åˆ‡æ¢ä¸åŒæ¨¡å¼ï¼Œæµ‹è¯•ä¸åŒå“åº”

### **6.3 å¸¸è§é—®é¢˜è§£å†³**
```
é—®é¢˜1ï¼šä¸²å£æ— è¾“å‡º
è§£å†³ï¼šæ£€æŸ¥TX/RXæ¥çº¿æ˜¯å¦æ­£ç¡®ï¼Œæ£€æŸ¥æ³¢ç‰¹ç‡è®¾ç½®

é—®é¢˜2ï¼šDHT11è¯»å–å¤±è´¥
è§£å†³ï¼šæ£€æŸ¥æ—¶åºï¼Œå¯èƒ½éœ€è¦è°ƒæ•´å»¶æ—¶

é—®é¢˜3ï¼šç¼–ç å™¨ååº”ä¸çµæ•
è§£å†³ï¼šè°ƒæ•´TIM3çš„æ»¤æ³¢å™¨è®¾ç½®ï¼Œæˆ–æ£€æŸ¥ç¡¬ä»¶è¿æ¥

é—®é¢˜4ï¼šOLEDæ˜¾ç¤ºå¼‚å¸¸
è§£å†³ï¼šæ£€æŸ¥I2Cåœ°å€æ˜¯å¦æ­£ç¡®ï¼ˆé€šå¸¸æ˜¯0x78æˆ–0x7Aï¼‰
```

## **7. é¡¹ç›®äº¤ä»˜æ¸…å•**

### **å¿…é¡»æäº¤çš„æ–‡ä»¶ï¼š**
```
1. Keilå·¥ç¨‹æ–‡ä»¶ (.uvprojx)
2. æ‰€æœ‰æºä»£ç  (.c/.h æ–‡ä»¶)
3. ç¡¬ä»¶è¿æ¥å›¾ (æ‰‹ç»˜æˆ–Fritzingå›¾)
4. ä¸²å£é€šä¿¡åè®®æ–‡æ¡£
5. æµ‹è¯•æŠ¥å‘Š
```

### **ä»£ç ç»“æ„å»ºè®®ï¼š**
```
SmartHome_Security_Project/
â”œâ”€â”€ Libraries/
â”‚   â”œâ”€â”€ CMSIS/
â”‚   â””â”€â”€ STM32F10x_StdPeriph_Drv/
â”œâ”€â”€ User/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ stm32f10x_it.c
â”‚   â”œâ”€â”€ system_stm32f10x.c
â”‚   â”œâ”€â”€ bsp/
â”‚   â”‚   â”œâ”€â”€ bsp_uart.c/.h
â”‚   â”‚   â”œâ”€â”€ bsp_oled.c/.h
â”‚   â”‚   â”œâ”€â”€ bsp_encoder.c/.h
â”‚   â”‚   â”œâ”€â”€ bsp_beep.c/.h
â”‚   â”‚   â”œâ”€â”€ bsp_led.c/.h
â”‚   â”‚   â””â”€â”€ bsp_delay.c/.h
â”‚   â”œâ”€â”€ drivers/
â”‚   â”‚   â”œâ”€â”€ dht11.c/.h
â”‚   â”‚   â””â”€â”€ infrared.c/.h
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ menu.c/.h
â”‚   â”‚   â””â”€â”€ security.c/.h
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ my_printf.c/.h
â””â”€â”€ Project/
    â””â”€â”€ SmartHome.uvprojx
```

---

**è¿™ä¸ªè¯¦ç»†è®¾è®¡æ–‡æ¡£åŒ…å«äº†å®Œæ•´å¯è¿è¡Œçš„ä»£ç æ¡†æ¶**ï¼ŒAIå¼€å‘è€…å¯ä»¥ç›´æ¥åŸºäºæ­¤è¿›è¡Œå¼€å‘ã€‚é‡ç‚¹æ³¨æ„ï¼š
1. **æ¨¡å—åŒ–å¼€å‘**ï¼šæ¯ä¸ªæ¨¡å—ç‹¬ç«‹æµ‹è¯•
2. **ä¸²å£è°ƒè¯•**ï¼šåˆ©ç”¨printfè¾“å‡ºè°ƒè¯•ä¿¡æ¯
3. **é€æ­¥é›†æˆ**ï¼šå…ˆå®ŒæˆåŸºç¡€é©±åŠ¨ï¼Œå†å®ç°åº”ç”¨é€»è¾‘
4. **å……åˆ†æµ‹è¯•**ï¼šæ¯ä¸ªåŠŸèƒ½ç‚¹éƒ½è¦éªŒè¯

æŒ‰ç…§è¿™ä¸ªè®¾è®¡ï¼Œå¤§çº¦éœ€è¦**3-4å¤©**å¯ä»¥å®Œæˆæ‰€æœ‰å¼€å‘å·¥ä½œã€‚